<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="enumerator-architectural-documentation">Enumerator Architectural Documentation</h1>
<h2 id="application-lifecycle">Application lifecycle</h2>
<p>The enumerator application is bootstrapped from the <code>main</code> function defined in <code>enumerator.py</code>. This function:</p>
<ul>
<li>Parses command line arguments using the Python <code>argparse</code> module</li>
<li>Invokes an input parser from the <code>input</code> module to parse the passed input file. Input parsers generate <code>Enumerator</code> objects.</li>
<li>Sets various parameters on the <code>Enumerator</code> object that is created, such as the maximum complex size and the maximum number of reactions to be enumerated.</li>
<li>Instructs the <code>Enumerator</code> object to run the reaction enumeration.</li>
<li>Invokes an output generator to serialize the output from the enumerator to a file.</li>
</ul>
<h2 id="key-data-structures">Key data structures</h2>
<p>The <code>utils</code> module defines several classes that are used to represent the state of the enumeration:</p>
<ul>
<li><code>Domain</code> objects represent single domains (continuous regions of nucleotides that hybridize as a unit).</li>
<li><code>Strand</code> objects represent strands---ordered collections of <code>Domain</code>s.</li>
<li><code>Complex</code> objects represent complexes of strands---comprised of an ordered list of <code>Strand</code>s and a secondary structure specifying how strands are hybridized together.</li>
<li><code>RestingState</code> objects represent collections of <code>Complex</code>es that form a resting state---that is, a complex with no outgoing fast reactions.</li>
</ul>
<p>Additionally, the <code>reactions</code> module defines the <code>ReactionPathway</code> class:</p>
<ul>
<li><code>ReactionPathway</code> objects represent a reaction between some number of substrate <code>Complex</code>es and some number of product <code>Complex</code>es.</li>
</ul>
<h2 id="reaction-functions">Reaction functions</h2>
<p>The <code>reactions</code> module defines a number of &quot;reaction functions&quot;; these functions correspond to different types of reactions---for instance, unimolecular binding (<code>bind11</code>), bimolecular binding (<code>bind21</code>), 3-way branch migration (<code>branch_3way</code>), etc. Reaction functions all accept some number of <code>Complex</code>es as arguments, and return a list of <code>ReactionPathway</code> objects. The number of arguments accepted by a reaction function (which is therefore also the number of substrates for the reaction) is its <em>arity</em>.</p>
<p>Reaction functions are grouped by their arity and their &quot;speed&quot; in two dictionaries within the <code>enumerator</code> module: <code>fast_reactions</code> and <code>slow_reactions</code>. Each is a dictionary where the keys are arities (e.g. 1 for unimolecular, 2 for bimolecular, etc.), and the values are lists of reaction functions. Currently, all unimolecular reaction functions are fast, and the <code>bind21</code> reaction is slow. The fast/slow distinction is used by the enumerator to group complexes into &quot;resting state complexes&quot; and &quot;transient complexes&quot;---resting state complexes exist in strongly-connected neighborhoods with no out-going fast reactions (&quot;resting states&quot;), while transient complexes are those complexes in neighborhoods with one or more outgoing fast reactions.</p>
<h2 id="reaction-enumeration">Reaction enumeration</h2>
<p>The main reaction enumeration is performed by the <code>Enumerator</code> class. The <code>Enumerator</code> class is initialized with a set of <code>Domain</code>s and <code>Strand</code>s, as well as a set of initial <code>Complex</code>es. The <code>enumerate</code> method is called to begin the following procedure, which exhaustively enumerates the network of possible reactions starting from those initial <code>Complex</code>es:</p>
<ul>
<li>First, fast reactions are considered between the initial complexes: For each complex in <code>initial_complexes</code>, the <code>process_neighborhood</code> method is called and passed that <code>Complex</code>.
<ul>
<li>This method generates the &quot;neighborhood&quot; of complexes reachable by fast reactions from the passed reaction, and classifies the resulting complexes as either transient or resting state. This is a depth-first search, which proceeds as follows:
<ul>
<li>The starting complex is placed in a list <code>_F</code> by itself.</li>
<li>While that list is not empty:
<ul>
<li>an element is taken from the list and <code>get_fast_reactions</code> is passed that complex. <code>get_fast_reactions</code> executes each of the reaction functions in <code>fast_reactions</code> on the passed complex.</li>
<li>Resulting <code>ReactionPathway</code> objects are added to the list <code>N_reactions</code>.</li>
<li>Product <code>Complex</code>es from these reactions are added to the list <code>_F</code> and the list <code>_N</code>.</li>
</ul></li>
<li>The <code>segment_neighborhood</code> function is passed the list <code>_N</code>, which contains all complexes that have been enumerated through fast reactions. <code>segment_neighborhood</code> breaks the complexes in <code>_N</code> into strongly-connected components using Tarjans' algorithm. The resulting <code>transient_state_complexes</code>, <code>resting_state_complexes</code>, and <code>resting_states</code> are collected into the appropriate lists and stored in the <code>Enumerator</code> object.</li>
</ul></li>
</ul></li>
<li>Slow reactions are then considered between all complexes classified as resting states. For each complex classified as a resting state:
<ul>
<li><code>get_slow_reactions</code> is called and passed the <code>Complex</code>. <code>get_slow_reactions</code> works similarly to <code>get_fast_reactions</code>: it executes each of the reactions in <code>slow_reactions</code>. However, while <code>fast_reactions</code> can only be unimolecular, reaction functions in <code>slow_reactions</code> may be bimolecular; therefore, <code>get_slow_reactions</code> must iterate through all complexes classified as resting states and attempt slow reactions between those complexes and the passed <code>complex</code>.</li>
<li>Resulting <code>ReactionPathway</code>s and product <code>Complex</code>es are collected. For each of the product <code>Complex</code>es, <code>process_neighborhood</code> is invoked. <code>process_neighborhood</code> enumerates fast reactions and segments strongly-connected components, as described above.</li>
</ul></li>
</ul>
<h2 id="input-and-output">Input and output</h2>
<p>The <code>input</code> module defines a number of <em>input parsers</em>, which are functions that accept input filenames and return <code>Enumerator</code> objects. The <code>output</code> module defines a number of <em>output generators</em>, which are functions that accept <code>Enumerator</code> objects and output filenames, and serialize the <code>Enumerator</code> objects to the output file as text.</p>
<p>Input parsers are collected in the <code>text_input_functions</code> and <code>load_input_functions</code> dictionaries of the <code>input</code> module. <code>text_input_functions</code> generate new <code>Enumerator</code> objects which can then be used to enumerate reactions; <code>load_input_functions</code> genereate <code>Enumerator</code> objects which have been serialized from a <em>previous</em> run of the enumerator.</p>
<p>Output parsers are collected in the <code>text_output_functions</code> and <code>graph_output_functions</code> dictionaries of the <code>output</code> module. <code>text_output_functions</code> contains text-based output generators, while <code>graph_output_functions</code> generate graphical output.</p>
</body>
</html>
