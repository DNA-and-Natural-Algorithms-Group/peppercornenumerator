#
#  output.py
#  EnumeratorProject
#
#  Created by Karthik Sarma on 6/21/10.
#  modifications by Stefan Badelt.
#

from peppercornenumerator import __version__
from peppercornenumerator.utils import natural_sort, PeppercornUsageError
from peppercornenumerator.condense import ReactionGraph

def format_conc_units(cplx, molarity='M'):
    ini = cplx._concentration[0]
    num = float(cplx._concentration[1])
    uni = cplx._concentration[2]
    if uni != 'M':
        raise PeppercornUsageError('Must specify concentration of complex {} in M'.format(cplx))

    if molarity == 'M':
        pass
    elif molarity == 'mM':
        num *= 1e3
    elif molarity == 'uM':
        num *= 1e6
    elif molarity == 'nM':
        num *= 1e9

    return ' '.join([ini, str(num), molarity])


def write_kernel(enumerator, pil, detailed = True, condensed = False, 
        composite = None, molarity = 'M', time = 's'):
    """Write the contents of :obj:`Enumerator()` into a KERNEL file.

    Args:
      enumerator (:obj:`Enumerator()`): The enumertor object.
      pil (filehandle): The filehandle to which the output is written to.
      concensed (bool, optional): Print condensed form. Defaults to False.
    """

    pil.write("# File generated by peppercorn-{}\n".format(__version__))

    # Print domains
    seen = set()
    pil.write("\n# Domain specifications \n")
    for dom in natural_sort(enumerator.domains):
        if dom.is_complement and not dom.nucleotides: 
            dom = ~dom
        if dom not in seen :
            if dom.nucleotides:
                pil.write("sequence {:s} = {} : {:d}\n".format(dom.name, dom.nucleotides, len(dom)))
            else :
                pil.write("length {:s} = {:d}\n".format(dom.name, len(dom)))
            seen.add(dom)

    if composite:
        pil.write("\n# Composite domains \n")
        for comp in composite:
            if comp[-1]=='*' and comp[:-1] in composite:
                continue
            pil.write("sup-sequence {} = {} : {:d}\n".format(
                comp, ' '.join(map(str, composite[comp])), sum(map(len,composite[comp]))))

    # Print resting complexes
    pil.write("\n# Resting complexes \n")
    for cplx in natural_sort(enumerator.resting_complexes):
        if cplx._concentration :
            pil.write("{:s} = {:s} @{}\n".format(cplx.name, cplx.kernel_string, 
                format_conc_units(cplx, molarity=molarity)))
        else:
            pil.write("{:s} = {:s}\n".format(cplx.name, cplx.kernel_string))
 
    if condensed :
        # Print resting macrostates
        enumCG = ReactionGraph(enumerator)
        enumCG.condense()
        pil.write("\n# Resting macrostates \n")
        for resting in natural_sort(enumerator.resting_sets):
            pil.write("macrostate {:s} = [{}]\n".format(resting, 
                ', '.join(map(str,resting.complexes))))

        # Print reactions
        pil.write("\n# Condensed reactions \n")
        for rxn in natural_sort(enumCG.condensed_reactions):
            pil.write("reaction {:s}\n".format(rxn.full_string(molarity, time)))

    if detailed :
        # Print transient complexes
        pil.write("\n# Transient complexes \n")
        for cplx in natural_sort(enumerator.transient_complexes):
            if cplx._concentration :
                pil.write("{:s} = {:s} @{}\n".format(cplx.name, cplx.kernel_string, 
                    format_conc_units(cplx, molarity=molarity)))
            else:
                pil.write("{:s} = {:s}\n".format(cplx.name, cplx.kernel_string))

        # Print reactions
        pil.write("\n# Detailed reactions \n")
        for rxn in natural_sort(enumerator.reactions):
            pil.write("reaction {:s}\n".format(rxn.full_string(molarity, time)))

def write_crn(enumerator, crn, condensed = False, molarity = 'M', time = 's'):
    crn.write("# File generated by peppercorn-{}\n".format(__version__))

    def format_rate_units(rxn, molarity, time):
        """ Reaction objects *always* specify rate in /M and /s.
        """
        rate = rxn.rate
        if time == 's':
            pass
        elif time == 'm':
            rate *= 60
        elif time == 'h':
            rate *= 3600
        else :
            raise NotImplementedError
    
        if molarity == 'M':
            pass
        elif molarity == 'mM':
            if rxn.arity[0] > 1:
                factor = rxn.arity[0] - 1
                rate /= (factor * 1e3)
        elif molarity == 'uM':
            if rxn.arity[0] > 1:
                factor = rxn.arity[0] - 1
                rate /= (factor * 1e6)
        elif molarity == 'nM':
            if rxn.arity[0] > 1:
                factor = rxn.arity[0] - 1
                rate /= (factor * 1e9)
        else :
            raise NotImplementedError
    
        return rate

    if condensed :
        enumCG = ReactionGraph(enumerator)
        enumCG.condense()

        # Print reactions
        crn.write("\n# Condensed reactions: concentration = {}, time = {}\n".format(molarity, time))
        for reaction in natural_sort(enumCG.condensed_reactions):
            crn.write("{} [k = {}]\n".format(reaction, format_rate_units(reaction, molarity, time)))
    else :
        # Print reactions
        crn.write("\n# Detailed reactions: concentration = {}, time = {}\n".format(molarity, time))
        for reaction in natural_sort(enumerator.reactions):
            crn.write("{} [k = {}]\n".format(reaction, format_rate_units(reaction, molarity, time)))


