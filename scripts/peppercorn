#!/usr/bin/env python

import os
import sys
import logging
import argparse

# Import global default variables from peppercornenumerator library
from peppercornenumerator.enumerator import MAX_COMPLEX_SIZE
from peppercornenumerator.enumerator import MAX_COMPLEX_COUNT
from peppercornenumerator.enumerator import MAX_REACTION_COUNT
from peppercornenumerator.reactions import branch_3way, branch_4way

# Import wrapper functions to initialize the Enumerator object.
from peppercornenumerator.input import text_input_functions, load_input_functions
# Import wrapper functions to output enumeration results
from peppercornenumerator.output import text_output_functions, graph_output_functions
from peppercornenumerator.utils import colors

version = __import__('peppercornenumerator').__version__

def add_peppercorn_args(parser):
    parser.add_argument('input_filename', action='store', default=None,
            nargs='?', help="Path to the input file (same as --infile)")
    parser.add_argument('--infile', action='store', default=None, help="""Path
            to the input file (same as listing the input filename after all
            arguments)""")
    parser.add_argument('--outfile', action='store', dest='output_filename',
            default=None, help="""Path to the output file (default: use the
            input filename, + '-enum', then add an extension based on the
            output type)""")
    parser.add_argument('-i', action='store', dest='input_format', default=None,
        help="Parse the input file using this format; one of: " +
        ", ".join(text_input_functions.keys() + load_input_functions.keys()) +
        ". (default: guess from the extension of --infile)")
    parser.add_argument('-o', action='store', dest='output_format', default='',
        help="Write the output file using this format; one or more (comma-separated) of: " +
        ", ".join( text_output_functions.keys() + graph_output_functions.keys()) +
        ". (default: guess from the extension of --outfile)")
    parser.add_argument( '-c', action='store_true', dest='condensed', default=False,
        help="Condense reactions into only resting complexes (default: %(default)s)")

    ## TODO: remove option -r ?
    parser.add_argument( '-r', action='store_true', dest='compute_rates', default=True,
        help="Compute reaction rates (default: %(default)s)")
    parser.add_argument( '--no-rates', action='store_false', dest='compute_rates',
        help="Don't compute reaction rates")
    parser.add_argument( '-d', action='store_true', dest='dry_run', default=False,
        help="Dry run---read input, write output; do not enumerate any reactions. (default: %(default)s)")
    parser.add_argument( '-s', action='store_true', dest='interactive', default=False,
        help="Interactive---display new reactions after each step. (default: %(default)s)")
    parser.add_argument( '-v', action='count', dest='verbose', default=0,
        help="Print more output (-vv for extra debugging information)")

    parser.add_argument( '--max-complex-size', '--complex-size', action='store',
        dest='MAX_COMPLEX_SIZE', default=MAX_COMPLEX_SIZE, type=int,
        help="Maximum number of strands allowed in a complex (used to prevent polymerization) (default: %(default)s)")
    parser.add_argument( '--max-complex-count', '--max-complexes', action='store', type=int,
        dest='MAX_COMPLEX_COUNT', default=MAX_COMPLEX_COUNT,
        help="Maximum number of complexes that may be enumerated before the enumerator halts. (default: %(default)s)")
    parser.add_argument( '--max-reaction-count', '--max-reactions', action='store', type=int,
        dest='MAX_REACTION_COUNT',
        default=MAX_REACTION_COUNT,
        help="Maximum number of reactions that may be enumerated before the enumerator halts. (default: %(default)s)")

    parser.add_argument( '--release-cutoff-1-1', action='store', type=int, default=6, metavar='<int>',
        help="Maximum number of bases that will be released spontaneously in a 1-1 `open` reaction.")
    parser.add_argument( '--release-cutoff-1-n', action='store', type=int, default=6, metavar='<int>',
        help="Maximum number of bases that will be released spontaneously in a 1-n `open` reaction.")
    parser.add_argument( '--release-cutoff', action='store', default=None, type=int, metavar='<int>',
        help="""Maximum number of bases that will be released spontaneously in
        an `open` reaction, for either 1-1 or 1-n reactions (overwrites both
        --release-cutoff-1-1 and --release-cutoff-1-n to the same value)""")

    parser.add_argument( '--k-slow', action='store', dest='k_slow', default=0.0, type=float,
        help="Unimolecular reactions slower than this rate will be discarded (default: %(default)f)")
    parser.add_argument( '--k-fast', action='store', dest='k_fast', default=0.0, type=float,
        help="Unimolecular reactions slower than this rate will be marked as slow (default: %(default)f)")

    parser.add_argument( '--reject-remote', action='store_true', 
        help="Discard remote toehold mediated 3-way and 4-way branch migration reactions. (default: %(default)s)")
    parser.add_argument( '--no-max-helix', action='store_true', 
        help="Do not apply 'max helix at a time' semantics to 3-way branch migration reactions.")

    parser.add_argument( '--bfs-ish', action='store_true', dest='bfs',
        help="When searching for bimolecular reactions, look to the oldest complexes first. (default: %(default)s)")
    parser.add_argument( '--ignore-branch-3way', action='store_true', dest='ignore_branch_3way',
        help="Ignore 3-way branch migration events during enumeration.  (default: %(default)s)")
    parser.add_argument( '--ignore-branch-4way', action='store_true', dest='ignore_branch_4way',
        help="Ignore 4-way branch migration events during enumeration.  (default: %(default)s)")

    parser.add_argument('--profile', action='store_true', dest='profile',
                        help="Enable statistical profiling")

    return


def main(cl_opts):
    logger = logging.getLogger()
    if cl_opts.verbose == 1:
        logger.setLevel(logging.INFO)
    elif cl_opts.verbose == 2:
        logger.setLevel(logging.DEBUG)
    elif cl_opts.verbose >= 3:
        logger.setLevel(logging.NOTSET)

    ch = logging.StreamHandler()

    class ColorFormatter(logging.Formatter):
        def __init__(self, msg, use_color=True):
            logging.Formatter.__init__(self, msg)
            self.use_color = use_color
            self.COLORS = {
                'DEBUG': colors.CYAN,
                'INFO': colors.BLUE,
                'WARNING': colors.YELLOW,
                'ERROR': colors.RED,
                'Exception': colors.PINK,
            }
            self.RESET = colors.ENDC

        def format(self, record):
            levelname = record.levelname
            if self.use_color:
                record.levelname = self.COLORS[levelname] + \
                    levelname + self.RESET
            return logging.Formatter.format(self, record)

    # logging.Formatter('%(levelname)s - %(message)s')
    formatter = ColorFormatter(
        '%(levelname)s %(message)s', use_color=sys.stdout.isatty())
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if cl_opts.verbose > 3:
        logging.warning("Verbosity greater than -vvv has no effect")

    title = "Peppercorn Domain-level Reaction Enumerator"
    banner = (colors.BOLD + title + colors.ENDC + " " +
              colors.GREEN + version +
              colors.ENDC if sys.stdout.isatty() else title +
              (" (%s)" % version))
    logging.info(banner)

    if cl_opts.infile:
        cl_opts.input_filename = cl_opts.infile

    if(cl_opts.input_filename is None):
        msg = "No input file specified. Exiting."
        logging.error(msg)
        raise SystemExit(msg)

    # If there was no input format given, guess from the file extension
    if (cl_opts.input_format is None):
        ext = os.path.splitext(cl_opts.input_filename)[1]
        cl_opts.input_format = ext.replace('.', '')
        if cl_opts.input_format is '':
            cl_opts.input_format = "pil"
            logging.info("No input format; assuming %s." %
                         cl_opts.input_format)
        else:
            logging.info("Guessing input format from input filename: %s" %
                         cl_opts.input_format)

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    # Attempt to load an input parser to generate an enumerator object #
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    cl_opts.input_format = cl_opts.input_format.lower()
    if (cl_opts.input_format in text_input_functions):
        logging.info("Reading input file : %s" % cl_opts.input_filename)
        enum = text_input_functions[cl_opts.input_format](
            cl_opts.input_filename)
    else:
        msg = "Unrecognized input format '%s'. Exiting." % cl_opts.input_format
        logging.error(msg)
        raise SystemExit(msg)

    # Print initial complexes
    logging.info("Initial complexes: ")
    for c in enum.initial_complexes:
        logging.info(c.kernel_string())

    # Transfer options to enumerator object
    if cl_opts.k_slow is not None:
        enum.k_slow = cl_opts.k_slow
    if cl_opts.k_fast is not None:
        enum.k_fast = cl_opts.k_fast

    if cl_opts.MAX_REACTION_COUNT is not None:
        enum.MAX_REACTION_COUNT = cl_opts.MAX_REACTION_COUNT

    if cl_opts.MAX_COMPLEX_COUNT is not None:
        enum.MAX_COMPLEX_COUNT = cl_opts.MAX_COMPLEX_COUNT

    if cl_opts.MAX_COMPLEX_SIZE is not None:
        enum.MAX_COMPLEX_SIZE = cl_opts.MAX_COMPLEX_SIZE
    
    enum.release_cutoff_1_1 = cl_opts.release_cutoff_1_1
    enum.release_cutoff_1_n = cl_opts.release_cutoff_1_n

    if cl_opts.release_cutoff:
        enum.release_cutoff = cl_opts.release_cutoff

    enum.remote_migration = not cl_opts.reject_remote 
    enum.greedy_migration = not cl_opts.no_max_helix

    enum.DFS = not cl_opts.bfs
    enum.interactive = cl_opts.interactive

    # Modify enumeration events based on command line options.
    if cl_opts.ignore_branch_3way:
        if branch_3way in enum.FAST_REACTIONS:
            enum.FAST_REACTIONS.remove(branch_3way)

    if cl_opts.ignore_branch_4way:
        if branch_4way in enum.FAST_REACTIONS:
            enum.FAST_REACTIONS.remove(branch_4way)

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    # Run reaction enumeration (or not) #
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    if cl_opts.dry_run:
        logging.info("Dry run (not enumerating any reactions)... ")
        enum.dry_run()
        logging.info("Done.")
    else:
        logging.info("Enumerating reactions...")
        if cl_opts.interactive:
            logging.info()
            logging.info("Interactive mode enabled: fast and slow reactions will be printed for each ")
            logging.info("complex as enumerated. Press ^C at any time to terminate and write accumulated")
            logging.info("complexes to output.")
            logging.info()
        if cl_opts.profile:
            import statprof
            statprof.start()
            try:
                enum.enumerate()
            finally:
                statprof.stop()
                statprof.display()
        else:
            enum.enumerate()
        logging.info("Done.")

    # Handle condensed reactions
    condensed = cl_opts.condensed
    if(condensed):
        logging.info("Output will be condensed to remove transient complexes.")

    # More robustly/conveniently guess the output filename(s)
    output_filename = cl_opts.output_filename
    output_formats = [of.strip().lower()
                      for of in cl_opts.output_format.split(",")]

    # if there were multiple output formats requested
    if(len(output_formats) > 1):

        # if there was no output filename given, tack a new suffix on the input
        # filename
        if output_filename is None:
            output_prefix = os.path.splitext(
                cl_opts.input_filename)[0] + "-enum"
        else:
            # we're going to ignore the suffix of the provided
            output_prefix = os.path.splitext(output_filename)[0]

        # come up with a list of (format, filename) pairs
        outputs = [(fmt, output_prefix + "." + fmt) for fmt in output_formats]
    else:
        # if there was no output format given but there was an output filename
        if output_filename is not None and len(output_formats) == 0:
            output_formats = [os.path.splitext(cl_opts.input_filename)[1]]

        # if there was no output filename given, tack a suffix on to the input
        # filename
        elif output_filename is None:
            if len(output_formats) == 0 or output_formats[0] == '':
                output_formats = ['pil']
                logging.info(
                    "No output format specified; assuming %s." %
                    output_formats[0])
            output_filename = os.path.splitext(cl_opts.input_filename)[
                0] + "-enum" + "." + output_formats[0]

        # one output format
        outputs = [(output_formats[0], output_filename)]

    # Print each requested output format
    for (output_format, output_filename) in outputs:

        # Attempt to load an output generator to serialize the enumerator
        # object to an output file
        mode = None
        if (output_format in text_output_functions):
            logging.info("Writing text output to file : %s as %s" %
                         (output_filename, output_format))
            mode = text_output_functions[output_format]
        elif (output_format in graph_output_functions):
            logging.info("Writing graph output to file : %s as %s" %
                         (output_filename, output_format))
            mode = graph_output_functions[output_format]

        if mode is not None:
            mode(
                enum,
                output_filename,
                output_condensed=condensed,
                output_rates=cl_opts.compute_rates,
                condense_options={
                    'k_fast': enum.k_fast,
                    'compute_rates': cl_opts.compute_rates})
        else:
            msg = "Unrecognized output format '%s'. Exiting." % output_format
            logging.error(msg)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="""Peppercorn: Domain-level
    nucleic acid reaction enumerator. See README.{html, pdf} for usage
    examples. """)
    add_peppercorn_args(parser)
    args = parser.parse_args()
    main(args)

