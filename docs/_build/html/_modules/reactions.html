

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>reactions &mdash; Enumerator v2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Enumerator v2 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Enumerator v2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for reactions</h1><div class="highlight"><pre>
<span class="c">#</span>
<span class="c">#  reactions.py</span>
<span class="c">#  EnumeratorProject</span>
<span class="c">#</span>
<span class="c">#  Created by Karthik Sarma on 4/18/10.</span>
<span class="c">#</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># TODO: fix naming!</span>
<span class="n">auto_name</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c"># TODO: refactor this</span>
<span class="n">RELEASE_CUTOFF</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c"># If true, 3 way branch migrations are always greedy</span>
<span class="n">UNZIP</span> <span class="o">=</span> <span class="bp">True</span>

<div class="viewcode-block" id="ReactionPathway"><a class="viewcode-back" href="../index.html#reactions.ReactionPathway">[docs]</a><span class="k">class</span> <span class="nc">ReactionPathway</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Represents a reaction node on a reaction graph. Has a list of reactants</span>
<span class="sd">	and a list of products, along with a name field to denote the type of</span>
<span class="sd">	reaction involved.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c"># TODO: This needs to be actually used!</span>
	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Default constructor. Takes a name, a list of reactants (Complexes) and</span>
<span class="sd">		a list of products (Complexes).</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_reactants</span> <span class="o">=</span> <span class="n">reactants</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_reactants</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_products</span> <span class="o">=</span> <span class="n">products</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_products</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		
	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_string</span><span class="p">()</span>
<span class="c">#		return &quot;ReactionPathway(%s)&quot; % (self.name)</span>
	
	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

	<span class="k">def</span> <span class="nf">full_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s">&quot;ReactionPathway(</span><span class="si">%s</span><span class="s">): </span><span class="si">%s</span><span class="s"> -&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reactants</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">))</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
		
	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">reactants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reactants</span>
		
	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">products</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_products</span>
		
	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> \
			   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reactants</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">reactants</span><span class="p">)</span> <span class="ow">and</span> \
			   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">products</span><span class="p">)</span>
			   
	<span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="n">out</span> <span class="o">=</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">out</span>
			
		<span class="n">out</span> <span class="o">=</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reactants</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reactants</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">out</span>
			
		<span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">products</span><span class="p">)</span>
			   
<div class="viewcode-block" id="ReactionPathway.normalize"><a class="viewcode-back" href="../index.html#reactions.ReactionPathway.normalize">[docs]</a>	<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Ensures that complexes appear on only one side of the reaction by</span>
<span class="sd">		removing them evenly from both sides until only one side has any.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">reactant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactants</span><span class="p">:</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">reactant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactants</span> <span class="ow">and</span> \
				   <span class="n">reactant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reactant</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reactant</span><span class="p">)</span>
				
				

</div></div>
<div class="viewcode-block" id="bind11"><a class="viewcode-back" href="../index.html#reactions.bind11">[docs]</a><span class="k">def</span> <span class="nf">bind11</span><span class="p">(</span><span class="n">reactant</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns a list of reaction pathways which can be produced by 1-1 binding </span>
<span class="sd">	reactions of the argument complex. The 1-1 binding reaction is the </span>
<span class="sd">	hybridization of two complementary unpaired domains within a single complex </span>
<span class="sd">	to produce a single unpseudoknotted product complex.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c"># tuple: (strand, domain)</span>
	<span class="n">outer_index</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">struct</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	<span class="n">strands</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span>
	<span class="n">reactions</span> <span class="o">=</span> <span class="p">[]</span>
		
	<span class="c"># We will loop over all unpaired domains</span>
	<span class="c"># TODO: we can just use the available_domains field of complexes to</span>
	<span class="c"># simplify this!</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_num</span><span class="p">,</span> <span class="n">outer_strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">domain_num</span><span class="p">,</span> <span class="n">outer_domain</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outer_strand</span><span class="o">.</span><span class="n">domains</span><span class="p">):</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="n">strand_num</span><span class="p">][</span><span class="n">domain_num</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
				<span class="c"># This is not an unpaired domain</span>
				<span class="k">continue</span>
			
			<span class="c"># For each unpaired domain, we loop over all higher-number unpaired</span>
			<span class="c"># domains</span>
			<span class="n">inner_strand</span> <span class="o">=</span> <span class="n">strand_num</span>
			<span class="n">inner_domain</span> <span class="o">=</span> <span class="n">domain_num</span> <span class="o">+</span> <span class="mi">1</span>
			
			<span class="k">while</span> <span class="p">(</span><span class="n">inner_strand</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)):</span>
				<span class="c"># If we&#39;re back where we started, then we&#39;ve traversed </span>
				<span class="c"># a whole loop</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inner_strand</span> <span class="o">==</span> <span class="n">strand_num</span><span class="p">)</span> <span class="ow">and</span> \
				   <span class="p">(</span><span class="n">inner_domain</span> <span class="o">==</span> <span class="n">domain_num</span><span class="p">):</span>
				   <span class="k">break</span>
				
				<span class="c"># If we&#39;re at the end of a strand, move to the next</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inner_domain</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="n">inner_strand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">)):</span>
					<span class="n">inner_domain</span> <span class="o">=</span> <span class="mi">0</span>
					<span class="n">inner_strand</span> <span class="o">=</span> <span class="n">inner_strand</span> <span class="o">+</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="n">inner_strand</span><span class="p">][</span><span class="n">inner_domain</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
					<span class="c"># This is not an unpaired domain; skip around the loop</span>
					<span class="c"># to return to an external loop by following the structure</span>
					<span class="n">struct_element</span> <span class="o">=</span> <span class="n">struct</span><span class="p">[</span><span class="n">inner_strand</span><span class="p">][</span><span class="n">inner_domain</span><span class="p">]</span>
					<span class="n">inner_strand</span> <span class="o">=</span> <span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">inner_domain</span> <span class="o">=</span> <span class="n">struct_element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="ow">not</span> <span class="n">outer_domain</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="n">inner_strand</span><span class="p">]</span><span class="o">.</span>
											   <span class="n">domains</span><span class="p">[</span><span class="n">inner_domain</span><span class="p">]):</span>
					<span class="c"># These domains aren&#39;t complementary</span>
					<span class="n">inner_domain</span> <span class="o">=</span> <span class="n">inner_domain</span> <span class="o">+</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># These domains can pair, add to the list</span>
					<span class="n">reactions</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">strand_num</span><span class="p">,</span> <span class="n">domain_num</span><span class="p">),</span> 
									 <span class="p">(</span><span class="n">inner_strand</span><span class="p">,</span> <span class="n">inner_domain</span><span class="p">)))</span>
					<span class="c"># Continue to loop</span>
					<span class="n">inner_domain</span> <span class="o">=</span> <span class="n">inner_domain</span> <span class="o">+</span> <span class="mi">1</span>
	
	<span class="n">products</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactions</span><span class="p">:</span>
		<span class="n">new_structure</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
		<span class="n">new_structure</span><span class="p">[</span><span class="n">d1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">d1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d2</span>
		<span class="n">new_structure</span><span class="p">[</span><span class="n">d2</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">d2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d1</span>
		<span class="n">product</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;+&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">,</span>
						  <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">)</span>		
		<span class="n">products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
	
	<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
		<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionPathway</span><span class="p">(</span><span class="s">&#39;bind11&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">reactant</span><span class="p">],</span> <span class="p">[</span><span class="n">product</span><span class="p">]))</span>

	<span class="c"># remove any duplicate reactions	</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">output</span>
		
	<span class="n">output</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
			<span class="k">del</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">output</span>
	</div>
<div class="viewcode-block" id="bind21"><a class="viewcode-back" href="../index.html#reactions.bind21">[docs]</a><span class="k">def</span> <span class="nf">bind21</span><span class="p">(</span><span class="n">reactant1</span><span class="p">,</span> <span class="n">reactant2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns a list of reaction pathways which can be produced by 2-1 binding </span>
<span class="sd">	reactions of the argument complexes. The 2-1 binding reaction is the </span>
<span class="sd">	hybridization of two complementary unpaired domains, each in a different </span>
<span class="sd">	complex, to produce a single, unpseudoknotted product complex containing </span>
<span class="sd">	all of the strands contained in either of the original complexes.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">r1_doms</span> <span class="o">=</span> <span class="n">reactant1</span><span class="o">.</span><span class="n">available_domains</span>
	<span class="n">r2_doms</span> <span class="o">=</span> <span class="n">reactant2</span><span class="o">.</span><span class="n">available_domains</span>
	
	<span class="n">interaction_list</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="c"># TODO: significant optimization likely possible here because the lists</span>
	<span class="c"># are sorted</span>
	
	<span class="n">new_complexes</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="c"># Iterate through all the free domains in reactant1</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">dom1</span><span class="p">,</span> <span class="n">strand_num1</span><span class="p">,</span> <span class="n">dom_num1</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r1_doms</span><span class="p">):</span>
		<span class="c"># For each, find any domains in reactant2 that could bind</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">dom2</span><span class="p">,</span> <span class="n">strand_num2</span><span class="p">,</span> <span class="n">dom_num2</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r2_doms</span><span class="p">):</span>
			<span class="c"># If it can pair, this is one possible reaction (this kind of</span>
			<span class="c"># reaction cannot possibly produce a pseudoknotted structure)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dom1</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">dom2</span><span class="p">)):</span>
				<span class="n">new_complexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combine_complexes_21</span><span class="p">(</span>
									 <span class="n">reactant1</span><span class="p">,</span> <span class="p">(</span><span class="n">strand_num1</span><span class="p">,</span> <span class="n">dom_num1</span><span class="p">),</span> 
								     <span class="n">reactant2</span><span class="p">,</span> <span class="p">(</span><span class="n">strand_num2</span><span class="p">,</span> <span class="n">dom_num2</span><span class="p">)))</span>
									 
	<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="nb">complex</span> <span class="ow">in</span> <span class="n">new_complexes</span><span class="p">:</span>
		<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionPathway</span><span class="p">(</span><span class="s">&#39;bind21&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">reactant1</span><span class="p">,</span> <span class="n">reactant2</span><span class="p">],</span> 
								      <span class="p">[</span><span class="nb">complex</span><span class="p">]))</span>
	
	<span class="k">return</span> <span class="n">output</span>
	
	</div>
<div class="viewcode-block" id="find_external_strand_break"><a class="viewcode-back" href="../index.html#reactions.find_external_strand_break">[docs]</a><span class="k">def</span> <span class="nf">find_external_strand_break</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Takes a complex and a location (strand+domain index) referring to a domain in</span>
<span class="sd">	the complex which is on an external loop. Returns the index of the last</span>
<span class="sd">	strand before the strand break which makes the argument domain on an</span>
<span class="sd">	external loop.</span>
<span class="sd">	</span>
<span class="sd">	The argument location is a tuple (strand_num, index_num)</span>
<span class="sd">	</span>
<span class="sd">	# TODO: This is really confusingly worded...</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">strand_num</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">domain_num</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	
	<span class="n">stop_flag</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="n">search_dom_index</span> <span class="o">=</span> <span class="n">domain_num</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="n">search_strand_index</span> <span class="o">=</span> <span class="n">strand_num</span>
	<span class="n">insertion_strand_index</span> <span class="o">=</span> <span class="bp">None</span>
	
	<span class="c"># We will first search to the &#39;right&#39;, looking for the first external</span>
	<span class="c"># strand break</span>
	<span class="k">while</span> <span class="n">insertion_strand_index</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
		<span class="c"># First check to see if we&#39;ve run off the end of a strand</span>
		<span class="c"># in which case the external break is between this strand and the</span>
		<span class="c"># next one</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_dom_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">complex</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">search_strand_index</span><span class="p">])):</span>
			<span class="n">insertion_strand_index</span> <span class="o">=</span> <span class="n">search_strand_index</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">paired_dom</span> <span class="o">=</span> <span class="nb">complex</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">search_strand_index</span><span class="p">]</span>\
										  <span class="p">[</span><span class="n">search_dom_index</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">paired_dom</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>			
				<span class="c"># If the current domain is unpaired, move to the next one</span>
				<span class="n">search_dom_index</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">elif</span> <span class="p">((</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">search_strand_index</span><span class="p">)</span> <span class="ow">or</span> \
					 <span class="p">((</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">search_strand_index</span><span class="p">)</span> <span class="ow">and</span> \
					  <span class="p">(</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">search_dom_index</span><span class="p">))):</span>
				<span class="c"># If the current domain is paired to something which is to the</span>
				<span class="c"># right of the current search domain, then we jump past that</span>
				<span class="c"># loop</span>
				<span class="n">search_strand_index</span> <span class="o">=</span> <span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">search_dom_index</span> <span class="o">=</span> <span class="n">paired_dom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c"># Otherwise the current domain is paired to something to the</span>
				<span class="c"># left of the current search domain, which means that the</span>
				<span class="c"># external strand break must be to the left</span>
				<span class="k">break</span>
				
	<span class="n">search_dom_index</span> <span class="o">=</span> <span class="n">domain_num</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="n">search_strand_index</span> <span class="o">=</span> <span class="n">strand_num</span>
	
	<span class="c"># We now search to the &#39;left&#39; if we haven&#39;t found the break yet</span>
	<span class="k">while</span> <span class="n">insertion_strand_index</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
		<span class="c"># First check to see if we&#39;ve run off the end of a strand, in which</span>
		<span class="c"># case the external break is between the previous strand and this one</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_dom_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">insertion_strand_index</span> <span class="o">=</span> <span class="n">search_strand_index</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">paired_dom</span> <span class="o">=</span> <span class="nb">complex</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">search_strand_index</span><span class="p">]</span> \
										  <span class="p">[</span><span class="n">search_dom_index</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">paired_dom</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>			
				<span class="c"># If the current domain is unpaired, move to the next one</span>
				<span class="n">search_dom_index</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="k">elif</span> <span class="p">((</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">search_strand_index</span><span class="p">)</span> <span class="ow">or</span> 
					 <span class="p">((</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">search_strand_index</span><span class="p">)</span> <span class="ow">and</span>
					  <span class="p">(</span><span class="n">paired_dom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">search_dom_index</span><span class="p">))):</span>
				<span class="c"># If the current domain is paired to something which is to the</span>
				<span class="c"># left of the current search domain, then we jump past that</span>
				<span class="c"># loop</span>
				<span class="n">search_strand_index</span> <span class="o">=</span> <span class="n">paired_dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">search_dom_index</span> <span class="o">=</span> <span class="n">paired_dom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c"># Otherwise the current domain is paired to something to the</span>
				<span class="c"># left of the current search domain, which means that the</span>
				<span class="c"># external strand break must be to the right; however we</span>
				<span class="c"># checked that, so there must have been an error...</span>
				<span class="k">raise</span> \
				    <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unexpected error in find_external_strand_break&quot;</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="n">insertion_strand_index</span>

</div>
<div class="viewcode-block" id="combine_complexes_21"><a class="viewcode-back" href="../index.html#reactions.combine_complexes_21">[docs]</a><span class="k">def</span> <span class="nf">combine_complexes_21</span><span class="p">(</span><span class="n">complex1</span><span class="p">,</span> <span class="n">location1</span><span class="p">,</span> <span class="n">complex2</span><span class="p">,</span> <span class="n">location2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Combines two complexes to form one complex, binding the domain in</span>
<span class="sd">	complex1 at location1 to the domain in complex2 at location2.</span>
<span class="sd">	</span>
<span class="sd">	Returns the new complex.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="c"># First we need to find the external strand breaks where we will be</span>
	<span class="c"># splitting the complexes</span>
	
	<span class="n">insertion_index_1</span> <span class="o">=</span> <span class="n">find_external_strand_break</span><span class="p">(</span><span class="n">complex1</span><span class="p">,</span> <span class="n">location1</span><span class="p">)</span>
	<span class="n">insertion_index_2</span> <span class="o">=</span> <span class="n">find_external_strand_break</span><span class="p">(</span><span class="n">complex2</span><span class="p">,</span> <span class="n">location2</span><span class="p">)</span>
		
	<span class="c"># We then find the four parts, 1-4, which we will stick together</span>
	<span class="c"># in order to create our final complex</span>
	
	<span class="c"># If this condition is true, we will need to cut up complex1</span>
	<span class="k">if</span> <span class="n">insertion_index_1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">d1</span> <span class="o">=</span> <span class="n">complex1</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">insertion_index_1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
		<span class="n">d4</span> <span class="o">=</span> <span class="n">complex1</span><span class="o">.</span><span class="n">strands</span><span class="p">[(</span><span class="n">insertion_index_1</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
		<span class="n">s1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex1</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">insertion_index_1</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
		<span class="n">s4</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex1</span><span class="o">.</span><span class="n">structure</span><span class="p">[(</span><span class="n">insertion_index_1</span><span class="o">+</span><span class="mi">1</span><span class="p">):])</span>	
	<span class="k">else</span><span class="p">:</span>
		<span class="n">d1</span> <span class="o">=</span> <span class="n">complex1</span><span class="o">.</span><span class="n">strands</span><span class="p">[:]</span>
		<span class="n">d4</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">s1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex1</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
		<span class="n">s4</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="c"># If this condition is true, we will need to cut up complex2	</span>
	<span class="k">if</span> <span class="n">insertion_index_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">d2</span> <span class="o">=</span> <span class="n">complex2</span><span class="o">.</span><span class="n">strands</span><span class="p">[(</span><span class="n">insertion_index_2</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
		<span class="n">d3</span> <span class="o">=</span> <span class="n">complex2</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">insertion_index_2</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
		<span class="n">s2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex2</span><span class="o">.</span><span class="n">structure</span><span class="p">[(</span><span class="n">insertion_index_2</span><span class="o">+</span><span class="mi">1</span><span class="p">):])</span>
		<span class="n">s3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex2</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">insertion_index_2</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">d2</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">d3</span> <span class="o">=</span> <span class="n">complex2</span><span class="o">.</span><span class="n">strands</span><span class="p">[:]</span>
		<span class="n">s2</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">s3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">complex2</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
	
	<span class="c"># We now need to update the structures based on the way things were shifted</span>
	<span class="c"># We calculate the offsets for strand locations in each chunk</span>
	<span class="n">s1_strand_offset</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">s2_strand_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">d3</span><span class="p">)</span>
	<span class="n">s3_strand_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
	<span class="n">s4_strand_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">d3</span><span class="p">)</span>
	
	
	<span class="c"># We then iterate through the structure and update as needed</span>
	<span class="k">if</span> <span class="n">insertion_index_1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand_list</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">dom_index</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand_list</span><span class="p">):</span>
				<span class="c"># If the domain is paired, check if it is paired to something </span>
				<span class="c"># in s4</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pair</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_1</span><span class="p">)):</span>
					<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s4_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="n">s1</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand_list</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dom_index</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand_list</span><span class="p">):</span>
			<span class="c"># If the domain is paired, check to see if it is paired to something</span>
			<span class="c"># in s2 or s3</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">):</span>
				<span class="c"># Check if paired to s2</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">insertion_index_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_2</span><span class="p">)):</span>
					<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="n">s2</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
				<span class="c"># Otherwise paired to s3</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s3_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="n">s2</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
	
		
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand_list</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s3</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dom_index</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand_list</span><span class="p">):</span>
			<span class="c"># If the domain is paired, check to see if it is paired to something</span>
			<span class="c"># in s2 or s3</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">):</span>
				<span class="c"># Check if paired to s2</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">insertion_index_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_2</span><span class="p">)):</span>
					<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="n">s3</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
				<span class="c"># Otherwise paired to s3</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s3_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="n">s3</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand_list</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s4</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dom_index</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand_list</span><span class="p">):</span>
			<span class="c"># Check if the domain is paired to something in s4</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pair</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_1</span><span class="p">)):</span>
				<span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s4_strand_offset</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">s4</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">dom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pair</span>
	
	<span class="n">new_strands</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">d3</span> <span class="o">+</span> <span class="n">d4</span>
	<span class="n">new_structure</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="n">s3</span> <span class="o">+</span> <span class="n">s4</span>
	
	<span class="c"># Finally, we need to update given reaction indices to new indices</span>
	<span class="c"># and then add the new pairing to the structure</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">insertion_index_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">location1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_1</span><span class="p">)):</span>
		<span class="n">location1</span> <span class="o">=</span> <span class="p">(</span><span class="n">location1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s4_strand_offset</span><span class="p">,</span> <span class="n">location1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	
	<span class="k">if</span> <span class="p">((</span><span class="n">insertion_index_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">location2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insertion_index_2</span><span class="p">)):</span>
		<span class="n">location2</span> <span class="o">=</span> <span class="p">(</span><span class="n">location2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2_strand_offset</span><span class="p">,</span> <span class="n">location2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">location2</span> <span class="o">=</span> <span class="p">(</span><span class="n">location2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s3_strand_offset</span><span class="p">,</span> <span class="n">location2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	
	<span class="n">new_structure</span><span class="p">[</span><span class="n">location1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">location1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">location2</span>
	<span class="n">new_structure</span><span class="p">[</span><span class="n">location2</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">location2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">location1</span>
	
	<span class="k">global</span> <span class="n">auto_name</span>
	
	<span class="n">new_complex</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">auto_name</span><span class="p">),</span> <span class="n">new_strands</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">)</span>
	<span class="n">auto_name</span> <span class="o">+=</span> <span class="mi">1</span>
	
	<span class="k">return</span> <span class="n">new_complex</span>
</div>
<div class="viewcode-block" id="open"><a class="viewcode-back" href="../index.html#reactions.open">[docs]</a><span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">reactant</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Returns a list of reaction product sets that can be produced by the</span>
<span class="sd">	&#39;open&#39; reaction, in which a short helix dissociates. Each product</span>
<span class="sd">	set are the results of one particular dissociation; each strand in the</span>
<span class="sd">	reactant occurs exactly once in one of the complexes in the product set.</span>
<span class="sd">	</span>
<span class="sd">	A dissociation can happen to any helix under the threshold length</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">product_sets</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="n">structure</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	<span class="n">strands</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span>
	
	
	<span class="c"># We loop through all</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">domain_index</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">):</span>
			<span class="c"># If the domain is unpaired, skip it</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="n">helix_startA</span> <span class="o">=</span> <span class="p">[</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span><span class="p">]</span>
			<span class="n">helix_startB</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">])</span>
			
			<span class="c"># If the domain is bound to an earlier domain, then we have</span>
			<span class="c"># already considered it, so skip it</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">helix_startA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
			     <span class="p">((</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">helix_startA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
				  <span class="p">(</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">])))):</span>
				<span class="k">continue</span>
			
			<span class="n">helix_endA</span> <span class="o">=</span> <span class="n">helix_startA</span><span class="p">[:]</span>
			<span class="n">helix_endB</span> <span class="o">=</span> <span class="n">helix_startB</span><span class="p">[:]</span>
						
			<span class="n">helix_length</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">length</span>
			
			<span class="c"># Now iterate through the whole helix to find the other end</span>
			<span class="c"># of this one</span>
			<span class="c"># (The helix ends at the first strand break from either direction)</span>
			<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
				<span class="n">helix_endA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">helix_endB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
				
				<span class="c"># If one of the strands has broken, the helix has ended</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">helix_endA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">strands</span><span class="p">[</span><span class="n">helix_endA</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
					<span class="k">break</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">helix_endB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
					<span class="k">break</span>
				
				
				<span class="c"># If these domains aren&#39;t bound to each other, the helix</span>
				<span class="c"># has ended</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">helix_endA</span><span class="p">)</span> <span class="o">!=</span> <span class="n">structure</span><span class="p">[</span><span class="n">helix_endB</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">helix_endB</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
					<span class="k">break</span>
				
				<span class="c"># Add the current domain to the current helix</span>
				<span class="n">helix_length</span> <span class="o">+=</span> <span class="n">strands</span><span class="p">[</span><span class="n">helix_endA</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">helix_endA</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
									   <span class="o">.</span><span class="n">length</span>
									   
			<span class="c"># We must also iterate in the other direction</span>
			<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
				<span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
				<span class="n">helix_startB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
				
				<span class="c"># If one of the strands has broken, the helix has ended</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
					<span class="k">break</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">strands</span><span class="p">[</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
					<span class="k">break</span>
				
				<span class="c"># If these domains aren&#39;t bound to each other, the helix</span>
				<span class="c"># has ended</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">helix_startA</span><span class="p">)</span> <span class="o">!=</span> <span class="n">structure</span><span class="p">[</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">helix_startB</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
					<span class="k">break</span>
				
				<span class="c"># Add the current domain to the current helix</span>
				<span class="n">helix_length</span> <span class="o">+=</span> <span class="n">strands</span><span class="p">[</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
									   <span class="o">.</span><span class="n">length</span>
				
			
			<span class="c"># Move start location to the first domain in the helix</span>
			<span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="n">helix_startB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
			
			<span class="c"># If the helix is short enough, we have a reaction	</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">helix_length</span> <span class="o">&lt;=</span> <span class="n">RELEASE_CUTOFF</span><span class="p">):</span>
				<span class="n">release_reactant</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reactant</span><span class="p">)</span>
				
				
				<span class="c"># Delete all the pairs in the released helix</span>
				<span class="k">for</span> <span class="n">dom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">helix_endA</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
					<span class="n">bound_loc</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">dom</span><span class="p">]</span>
					<span class="n">release_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">helix_startA</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">dom</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
					<span class="n">release_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
		
		
				<span class="n">product_set</span> <span class="o">=</span> <span class="n">find_releases</span><span class="p">(</span><span class="n">release_reactant</span><span class="p">)</span>
				
				
				<span class="n">product_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">product_set</span><span class="p">)</span>
		
	<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">product_set</span> <span class="ow">in</span> <span class="n">product_sets</span><span class="p">:</span>
		<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionPathway</span><span class="p">(</span><span class="s">&#39;open&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">reactant</span><span class="p">],</span> <span class="n">product_set</span><span class="p">))</span>
	
	<span class="k">return</span> <span class="n">output</span>
	
	</div>
<div class="viewcode-block" id="find_releases"><a class="viewcode-back" href="../index.html#reactions.find_releases">[docs]</a><span class="k">def</span> <span class="nf">find_releases</span><span class="p">(</span><span class="n">reactant</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Determines if reactant actually represents multiple unattached complexes.</span>
<span class="sd">	If so, returns a list of these complexes. Otherwise, returns [reactant].</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="n">structure</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	<span class="n">strands</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span>
	
	<span class="n">output_list</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="c"># Iterate through the strands and determine if a split is necessary</span>
	<span class="c"># Note that we don&#39;t iterate to the last strand because if the last</span>
	<span class="c"># strand were free from the rest, we would catch that as the rest</span>
	<span class="c"># of the strands being free from the last strand. Hence, we also</span>
	<span class="c"># terminate loops if we ever get to the last strand</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
		
		<span class="n">domain_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">)</span>
		
		<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		
		<span class="c"># We now iterate through lower domains and see if we can find</span>
		<span class="c"># a release point</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> \
			  <span class="p">((</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">strand_index</span><span class="p">)</span> <span class="ow">or</span> \
			  <span class="p">((</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">strand_index</span><span class="p">)</span> <span class="ow">and</span> \
			  <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">domain_index</span><span class="p">))):</span>

			<span class="c"># If we have run off of the end of a strand,</span>
			<span class="c"># then we have found a release point  </span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">split_start</span> <span class="o">=</span> <span class="n">inner_index</span>
				<span class="n">split_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span><span class="p">)</span>
				<span class="n">split_list</span> <span class="o">=</span> <span class="n">split_complex</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> <span class="n">split_start</span><span class="p">,</span> <span class="n">split_end</span><span class="p">)</span>
				<span class="c"># We check the two resulting complexes to see if they can</span>
				<span class="c"># be split further</span>
				<span class="k">for</span> <span class="nb">complex</span> <span class="ow">in</span> <span class="n">split_list</span><span class="p">:</span>
					<span class="n">output_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">find_releases</span><span class="p">(</span><span class="nb">complex</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">output_list</span>					
			
			<span class="c"># Otherwise decide where to go next</span>
			<span class="n">curr_structure</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
						
			<span class="c"># If this domain is unpaired, move to the next</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_structure</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			
			<span class="c"># Check if the structure points to a higher domain </span>
			<span class="k">elif</span> <span class="p">((</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
			     <span class="p">((</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
				  <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]))):</span>

				<span class="c"># If the structure points to a domain above the start, this section</span>
				<span class="c"># is connected to something higher, so abort this loop</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strand_index</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
					<span class="k">break</span>
				  				  
				<span class="c"># Otherwise it points to a domain between this one and the start</span>
				<span class="c"># -- we&#39;ve already been there so move to the next</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>			
				
			<span class="c"># Otherwise, follow the structure</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="n">curr_structure</span>

<span class="c">##### TODO: FIND OUT IF THIS IS NEEDED...</span>
		<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				
		<span class="c"># If we didn&#39;t find a release point in the lower domains,</span>
		<span class="c"># we now try iterating through the higher domains</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> \
			  <span class="p">((</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strand_index</span><span class="p">)</span> <span class="ow">or</span> \
			  <span class="p">((</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">strand_index</span><span class="p">)</span> <span class="ow">and</span> \
			  <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">domain_index</span><span class="p">))):</span>
			<span class="c"># If we have run off of the end of a strand,</span>
			<span class="c"># then we have found a release point  </span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">)):</span>
				<span class="n">split_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span><span class="p">)</span>
				<span class="n">split_end</span> <span class="o">=</span> <span class="n">inner_index</span>
				<span class="n">split_list</span> <span class="o">=</span> <span class="n">split_complex</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> <span class="n">split_start</span><span class="p">,</span> <span class="n">split_end</span><span class="p">)</span>
				<span class="c"># We check the two resulting complexes to see if they can</span>
				<span class="c"># be split further</span>
				<span class="k">for</span> <span class="nb">complex</span> <span class="ow">in</span> <span class="n">split_list</span><span class="p">:</span>
					<span class="n">output_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">find_releases</span><span class="p">(</span><span class="nb">complex</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">output_list</span>					
							
			<span class="c"># Otherwise decide where to go next</span>
			<span class="n">curr_structure</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>	
			
			<span class="c"># If this domain is unpaired, move to the next</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_structure</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

			<span class="c"># Check if the structure points to a lower domain			</span>
			<span class="k">elif</span> <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
				 <span class="p">((</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
				  <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
				  
				<span class="c"># If the structure points to a domain before the start,</span>
				<span class="c"># this section is connected to something lower, so abort this</span>
				<span class="c"># loop</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">strand_index</span><span class="p">):</span>
					<span class="k">break</span>
				
				<span class="c"># Otherwise it points to a domain between this one and the start</span>
				<span class="c"># -- we&#39;ve already been there to move to the next</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inner_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>			
			
			
			<span class="c"># Otherwise, follow the structure</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">inner_index</span> <span class="o">=</span> <span class="n">curr_structure</span>			
				
	<span class="c"># If we still haven&#39;t found any splits, then this complex cannot be split</span>
	
	<span class="k">return</span> <span class="p">[</span><span class="n">reactant</span><span class="p">]</span>
	</div>
<div class="viewcode-block" id="split_complex"><a class="viewcode-back" href="../index.html#reactions.split_complex">[docs]</a><span class="k">def</span> <span class="nf">split_complex</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> <span class="n">split_start</span><span class="p">,</span> <span class="n">split_end</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Splits a disconnected complex between split_start and split_end (which</span>
<span class="sd">	should be at ends of strands), and returns the two resulting complexes.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="n">strands</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span>
	<span class="n">structure</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	
	<span class="c"># We first take the parts apart</span>
	<span class="n">strands1</span> <span class="o">=</span> <span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
	<span class="n">structure1</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
	
	<span class="n">strands2</span> <span class="o">=</span> <span class="n">strands</span><span class="p">[</span><span class="n">split_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">split_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">structure2</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">split_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">split_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	
	<span class="n">strands3</span> <span class="o">=</span> <span class="n">strands</span><span class="p">[</span><span class="n">split_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
	<span class="n">structure3</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">split_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
	
	<span class="n">out1_strands</span> <span class="o">=</span> <span class="n">strands1</span> <span class="o">+</span> <span class="n">strands3</span>
	<span class="n">out2_strands</span> <span class="o">=</span> <span class="n">strands2</span>
		
		
	<span class="c"># These offsets are the changes to the strand numbers needed</span>
	<span class="n">structure2_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands1</span><span class="p">)</span>
	<span class="n">structure3_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands2</span><span class="p">)</span>

	<span class="c"># Apply offset to structure2</span>
	<span class="n">new_structure1</span> <span class="o">=</span> <span class="p">[]</span>
			
	<span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">structure1</span><span class="p">:</span>
		<span class="n">strand_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">struct_element</span> <span class="ow">in</span> <span class="n">strand</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">struct_element</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
			<span class="k">elif</span> <span class="p">(</span><span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">split_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">structure3_offset</span><span class="p">,</span> <span class="n">struct_element</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_element</span><span class="p">)</span>
		<span class="n">new_structure1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand_out</span><span class="p">)</span>
	
			
	<span class="c"># Apply offset to structure2</span>
	<span class="n">new_structure2</span> <span class="o">=</span> <span class="p">[]</span>
		
	<span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">structure2</span><span class="p">:</span>
		<span class="n">strand_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">struct_element</span> <span class="ow">in</span> <span class="n">strand</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">struct_element</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">structure2_offset</span><span class="p">,</span> <span class="n">struct_element</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">new_structure2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand_out</span><span class="p">)</span>
		
	<span class="c"># Apply offset to structure3</span>
	<span class="n">new_structure3</span> <span class="o">=</span> <span class="p">[]</span>
	
	
	<span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">structure3</span><span class="p">:</span>
		<span class="n">strand_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">struct_element</span> <span class="ow">in</span> <span class="n">strand</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">struct_element</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
			<span class="k">elif</span> <span class="p">(</span><span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">split_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_element</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">strand_out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">struct_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">structure3_offset</span><span class="p">,</span> <span class="n">struct_element</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">new_structure3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand_out</span><span class="p">)</span>
		
	<span class="n">out1_structure</span> <span class="o">=</span> <span class="n">new_structure1</span> <span class="o">+</span> <span class="n">new_structure3</span>
	<span class="n">out2_structure</span> <span class="o">=</span> <span class="n">new_structure2</span>
	
	<span class="k">global</span> <span class="n">auto_name</span>
	
	<span class="n">out1</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">auto_name</span><span class="p">),</span> <span class="n">out1_strands</span><span class="p">,</span> <span class="n">out1_structure</span><span class="p">)</span>
	<span class="n">auto_name</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="n">out2</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">auto_name</span><span class="p">),</span> <span class="n">out2_strands</span><span class="p">,</span> <span class="n">out2_structure</span><span class="p">)</span>
	<span class="n">auto_name</span> <span class="o">+=</span> <span class="mi">1</span>
	
	<span class="k">return</span> <span class="p">[</span><span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="branch_3way"><a class="viewcode-back" href="../index.html#reactions.branch_3way">[docs]</a><span class="k">def</span> <span class="nf">branch_3way</span><span class="p">(</span><span class="n">reactant</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Returns a list of reaction pathways that can be created through one </span>
<span class="sd">	iteration of a 3 way branch migration reaction (more than one molecule may </span>
<span class="sd">	be produced by a reaction because branch migration can liberate strands and </span>
<span class="sd">	complexes).</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="n">output_sets</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">structure</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	
	<span class="c"># We iterate through all the domains</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">domain_index</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">):</span>
			<span class="c"># We will search in both directions</span>
			<span class="c"># First direction:</span>
			
			<span class="c"># The starting domain must be anchored</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="c"># The starting domain must have another (displacing) domain </span>
			<span class="c"># next to it</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">strand_index</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="c"># The displacing domain must be free			</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="n">displacing_domain</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
			
			<span class="c"># We now follow the external loop from the starting pair</span>
			<span class="c"># searching for a strand to displace</span>
			<span class="n">bound_loc</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span>
			<span class="n">bound_loc_orig</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span>
			<span class="c"># Follow the external loop to the end</span>
			<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>				
				<span class="n">bound_loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="c"># Check if we&#39;ve reached the end of the external loop</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
					<span class="c"># Reached the end</span>
					<span class="k">break</span>
				
				
				
				<span class="c"># Check if this domain is unbound</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
					<span class="k">continue</span>
					
				<span class="c"># Check to see if this domain is complementary</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
							<span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">displacing_domain</span><span class="p">)):</span>
					<span class="c"># We have found a displacement reaction</span>
					<span class="n">output_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_3way_migration</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span>
														 <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> 
														 <span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
														 <span class="n">bound_loc</span><span class="p">))</span>
					
					
				<span class="c"># follow the structure</span>
				
				<span class="n">bound_loc</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
				<span class="k">if</span> <span class="n">bound_loc</span> <span class="o">==</span> <span class="n">bound_loc_orig</span><span class="p">:</span>
					<span class="c"># Caught in a loop</span>
					<span class="k">break</span>
			

	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">domain_index</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">):</span>			
			<span class="c"># Second direction:</span>

			<span class="c"># The starting domain must be anchored</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
						
			<span class="c"># The starting domain must have another (displacing) domain </span>
			<span class="c"># next to it</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="k">continue</span>
				
			<span class="c"># The displacing domain must be free			</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
				
			<span class="n">displacing_domain</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
			
			<span class="c"># We now follow the external loop from the starting pair</span>
			<span class="c"># searching for a strand to displace</span>
			<span class="n">bound_loc</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span>
			<span class="n">bound_loc_orig</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span>
			<span class="c"># Follow the external loop to the end</span>
			<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
				<span class="n">bound_loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
				
				<span class="c"># Check if we&#39;ve reached the end of the external loop</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
					<span class="c"># Reached the end</span>
					<span class="k">break</span>
					
				<span class="c"># Check if this domain is unbound</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
					<span class="k">continue</span>
					
				<span class="c"># Check to see if this domain is complementary</span>
				<span class="k">elif</span> <span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
							<span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">displacing_domain</span><span class="p">)):</span>
					<span class="c"># We have found a displacement reaction</span>
					<span class="n">output_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_3way_migration</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span>
														 <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> 
														 <span class="n">domain_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
														 <span class="n">bound_loc</span><span class="p">))</span>
					
					
				
				<span class="n">bound_loc</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
				<span class="k">if</span> <span class="n">bound_loc</span> <span class="o">==</span> <span class="n">bound_loc_orig</span><span class="p">:</span>
					<span class="k">break</span>
				
	<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">output_set</span> <span class="ow">in</span> <span class="n">output_sets</span><span class="p">:</span>
		<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionPathway</span><span class="p">(</span><span class="s">&#39;branch_3way&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">reactant</span><span class="p">],</span> <span class="n">output_set</span><span class="p">))</span>		

	<span class="c"># Remove any duplicate reactions</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">output</span>
		
	<span class="n">output</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
			<span class="k">del</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	
	<span class="k">return</span> <span class="n">output</span>

</div>
<div class="viewcode-block" id="do_3way_migration"><a class="viewcode-back" href="../index.html#reactions.do_3way_migration">[docs]</a><span class="k">def</span> <span class="nf">do_3way_migration</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> <span class="n">displacing_loc</span><span class="p">,</span> <span class="n">new_bound_loc</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Returns the product set which is the result of a 3-way branch migration</span>
<span class="sd">	reaction where the domain at displacing_loc displaces the domain bound to</span>
<span class="sd">	the domain at new_bound_loc.</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">out_reactant</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reactant</span><span class="p">)</span>
	<span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">displacing_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">displacing_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_bound_loc</span>
	<span class="n">displaced_loc</span> <span class="o">=</span> <span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
	<span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">displacing_loc</span>
	<span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">displaced_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">displaced_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
	
	<span class="k">global</span> <span class="n">auto_name</span>
	
	<span class="n">out_reactant</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">auto_name</span><span class="p">)</span>
	<span class="n">auto_name</span> <span class="o">+=</span> <span class="mi">1</span>
	
	<span class="k">global</span> <span class="n">UNZIP</span>
	
	<span class="c"># Check to see if an adjacent displacement is possible</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UNZIP</span><span class="p">):</span>
		<span class="n">dstrand</span> <span class="o">=</span> <span class="n">displacing_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">ddomain</span> <span class="o">=</span> <span class="n">displacing_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">bstrand</span> <span class="o">=</span> <span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">bdomain</span> <span class="o">=</span> <span class="n">new_bound_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ddomain</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">dstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">dstrand</span><span class="p">][</span><span class="n">ddomain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bdomain</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">bstrand</span><span class="p">][</span><span class="n">bdomain</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">bdomain</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">dstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">ddomain</span><span class="o">+</span><span class="mi">1</span><span class="p">])):</span>
			<span class="k">return</span> <span class="n">do_3way_migration</span><span class="p">(</span><span class="n">out_reactant</span><span class="p">,</span> <span class="p">(</span><span class="n">dstrand</span><span class="p">,</span> <span class="n">ddomain</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">bstrand</span><span class="p">,</span> <span class="n">bdomain</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">elif</span> <span class="p">(</span><span class="n">ddomain</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">dstrand</span><span class="p">][</span><span class="n">ddomain</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bdomain</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">bstrand</span><span class="p">][</span><span class="n">bdomain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">bstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">bdomain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">out_reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">dstrand</span><span class="p">]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">ddomain</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
			<span class="k">return</span> <span class="n">do_3way_migration</span><span class="p">(</span><span class="n">out_reactant</span><span class="p">,</span> <span class="p">(</span><span class="n">dstrand</span><span class="p">,</span> <span class="n">ddomain</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">bstrand</span><span class="p">,</span> <span class="n">bdomain</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">find_releases</span><span class="p">(</span><span class="n">out_reactant</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">find_releases</span><span class="p">(</span><span class="n">out_reactant</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="branch_4way"><a class="viewcode-back" href="../index.html#reactions.branch_4way">[docs]</a><span class="k">def</span> <span class="nf">branch_4way</span><span class="p">(</span><span class="n">reactant</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Returns a list of complex sets that can be created through one iteration of</span>
<span class="sd">	a 4 way branch migration reaction (each set consists of the molecules that</span>
<span class="sd">	result from the iteration; more than one molecule may result because branch</span>
<span class="sd">	migration can liberate strands and complexes).	</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="n">structure</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">structure</span>
	<span class="n">output_sets</span> <span class="o">=</span> <span class="p">[]</span>
	
	<span class="c"># We loop through all domains</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">):</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">domain_index</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">domains</span><span class="p">):</span>
			<span class="c"># Unbound domains can&#39;t participate in branch migration</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="c"># This domain can&#39;t be at the end of a strand</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">strand_index</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
				<span class="k">continue</span>
			
			
			<span class="c"># Check the 4 locations for a 4 way reaction</span>
			
			<span class="c"># Displacing domain</span>
			<span class="n">loc1</span> <span class="o">=</span> <span class="p">(</span><span class="n">strand_index</span><span class="p">,</span> <span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dom1</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">loc1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">loc1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

			<span class="c"># Displaced domain</span>
			<span class="n">loc2</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loc2</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			<span class="n">dom2</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">loc2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">loc2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
			
			<span class="c"># Template domain (replaces displaced domain, binds loc1)</span>
			<span class="n">loc3</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">strand_index</span><span class="p">][</span><span class="n">domain_index</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loc3</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			
			<span class="n">loc3</span> <span class="o">=</span> <span class="p">(</span><span class="n">loc3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loc3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
				<span class="k">continue</span>
			<span class="n">dom3</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">loc3</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">loc3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
			
			<span class="c"># Displaced from template domain (replaces displacing domain, binds</span>
			<span class="c">#								  loc2)</span>
			<span class="n">loc4</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">loc3</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loc4</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
				<span class="k">continue</span>
			<span class="n">dom4</span> <span class="o">=</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[</span><span class="n">loc4</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">loc4</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
			
			<span class="c"># Confirm that the domains can in fact pair</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dom1</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">dom3</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dom2</span><span class="o">.</span><span class="n">can_pair</span><span class="p">(</span><span class="n">dom4</span><span class="p">)):</span>
				<span class="k">continue</span>
				
			<span class="c"># Confirm that this is a four way migration</span>
			<span class="k">if</span> <span class="n">loc2</span> <span class="o">==</span> <span class="n">loc3</span><span class="p">:</span>
				<span class="k">continue</span>
				
			<span class="c"># If we are here, then we have found a candidate reaction</span>
			<span class="n">output_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_4way_migration</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> 
												 <span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">loc3</span><span class="p">,</span> <span class="n">loc4</span><span class="p">))</span>
	
	<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">output_set</span> <span class="ow">in</span> <span class="n">output_sets</span><span class="p">:</span>
		<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionPathway</span><span class="p">(</span><span class="s">&#39;branch_4way&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">reactant</span><span class="p">],</span> <span class="n">output_set</span><span class="p">))</span>
	
	<span class="c"># remove any duplicate reactions	</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">output</span>
		
	<span class="n">output</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
			<span class="k">del</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	
	<span class="k">return</span> <span class="n">output</span>
	</div>
<div class="viewcode-block" id="do_4way_migration"><a class="viewcode-back" href="../index.html#reactions.do_4way_migration">[docs]</a><span class="k">def</span> <span class="nf">do_4way_migration</span><span class="p">(</span><span class="n">reactant</span><span class="p">,</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">loc3</span><span class="p">,</span> <span class="n">loc4</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Performs a 4 way branch migration on a copy of reactant, with loc1 as the</span>
<span class="sd">	displacing domain, loc2 as the domain displaced from loc1, loc3 as the</span>
<span class="sd">	template domain, and loc4 as the domain displaced from loc3. Returns the</span>
<span class="sd">	set of complexes produced by this reaction (may be one or more complexes).</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">new_struct</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reactant</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
	<span class="n">new_struct</span><span class="p">[</span><span class="n">loc1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc3</span>
	<span class="n">new_struct</span><span class="p">[</span><span class="n">loc3</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc1</span>
	<span class="n">new_struct</span><span class="p">[</span><span class="n">loc2</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc4</span>
	<span class="n">new_struct</span><span class="p">[</span><span class="n">loc4</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc4</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc2</span>
	
	<span class="k">global</span> <span class="n">auto_name</span>
	
	<span class="n">out</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">auto_name</span><span class="p">),</span> <span class="n">reactant</span><span class="o">.</span><span class="n">strands</span><span class="p">[:],</span> <span class="n">new_struct</span><span class="p">)</span>
	<span class="n">auto_name</span> <span class="o">+=</span> <span class="mi">1</span>
	
	<span class="k">return</span> <span class="n">find_releases</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Enumerator v2 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Karthik Sarma, Brian Wolfe, Erik Winfree.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>